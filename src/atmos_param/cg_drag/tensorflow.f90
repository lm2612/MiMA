  !-----------------------------------------------------------------
  !    This module was auto-generated by process_model,
  !    and then edited to match the signatures required.
  !
  !-----------------------------------------------------------------
  
module cg_drag_ML_mod
    use TF_Types
    use TF_Interface

use constants_mod, only:  RADIAN

    implicit none

    public cg_drag_ML_init, &
        cg_drag_ML, &
        cg_drag_ML_end, &
        associate_tensor

    ! Interface for `associate_tensor` functions
    interface associate_tensor
        module procedure r64_2_associate_tensor
    end interface associate_tensor

    ! Each model needs a session and a graph variable.
    ! Model: saved_model/
    type(TF_Session) :: model_session_1
    type(TF_Graph) :: model_graph_1

    ! Input and output details
    type(TF_Output), dimension(3) :: inputs_1
    type(TF_Output), dimension(1) :: outputs_1

    contains

    subroutine cg_drag_ML_init(model_dir, model_name)

  !-----------------------------------------------------------------
  !    cg_drag_ML_init is called from cg_drag_init and initialises
  !    anything required for the ML calculation of cg_drag such as
  !    an ML model
  !
  !-----------------------------------------------------------------
  
  !-----------------------------------------------------------------
  !    intent(in) variables:
  !
  !       model_dir    full filepath to the model directory
  !       model_name   filename of the TorchScript model
  !
  !    Note that the TensorFlow model path is a directory name
  !    so model_name will be ignored.
  !
  !-----------------------------------------------------------------
        ! Parameters
        character(*) :: model_dir, model_name

        ! Filenames for directories containing models
        character(1024), dimension(1) :: model_dirs

        character(5), dimension(1, 1) :: tags
        integer :: i

        ! Assign the tags
        tags(1, 1) = 'serve'

        ! Rather than hard-coding the filenames here, you probably
        ! want to load them from a config file or similar.
        model_dirs(1) = trim(model_dir) // trim(model_name)

        ! Load all the models.
        ! If you have a model with different needs (tags, etc)
        ! edit this to handle that model separately.

        ! Model: saved_model/
        model_graph_1 = TF_NewGraph()
        call load_model(model_session_1, &
            model_graph_1, &
            tags(:, 1), model_dirs(1))

        ! Populate the input / output operations.
        ! Input for 'saved_model/' input 'input_lat'
        inputs_1(1)%oper = TF_GraphOperationByName( &
            model_graph_1, &
            'serving_default_input_lat' &
        )
        if (.not.c_associated(inputs_1(1)%oper%p)) then
            write(*,*)'inputs_1(1) not associated'
            stop
        endif
        inputs_1(1)%index = 0

        ! Input for 'saved_model/' input 'input_press'
        inputs_1(2)%oper = TF_GraphOperationByName( &
            model_graph_1, &
            'serving_default_input_press' &
        )
        if (.not.c_associated(inputs_1(2)%oper%p)) then
            write(*,*)'inputs_1(2) not associated'
            stop
        endif
        inputs_1(2)%index = 0

        ! Input for 'saved_model/' input 'input_wind'
        inputs_1(3)%oper = TF_GraphOperationByName( &
            model_graph_1, &
            'serving_default_input_wind' &
        )
        if (.not.c_associated(inputs_1(3)%oper%p)) then
            write(*,*)'inputs_1(3) not associated'
            stop
        endif
        inputs_1(3)%index = 0

        ! Output for 'saved_model/' output 'normalization'
        outputs_1(1)%oper = TF_GraphOperationByName( &
            model_graph_1, &
            'StatefulPartitionedCall' &
        )
        if (.not.c_associated(outputs_1(1)%oper%p)) then
            write(*,*)'outputs_1(1) not associated'
            stop
        endif
        outputs_1(1)%index = 0

    end subroutine cg_drag_ML_init

    subroutine load_model(session, graph, tags, model_dir)

        type(TF_Session) :: session
        type(TF_Graph) :: graph
        character(*), dimension(:) :: tags
        character(*) :: model_dir

        type(TF_SessionOptions) :: sessionoptions
        type(TF_Status) :: stat
        character(100) :: message

        sessionoptions = TF_NewSessionOptions()
        stat = TF_NewStatus()

        session = TF_LoadSessionFromSavedModel(sessionoptions, &
            model_dir, &
            tags, size(tags, 1), graph, stat)

        if (TF_GetCode( stat ) .ne. TF_OK) then
            call TF_Message( stat, message )
            write(*,*) TF_GetCode( stat ), message
            stop
        endif

        call TF_DeleteSessionOptions(sessionoptions)
        call TF_DeleteStatus(stat)

    end subroutine load_model


    subroutine cg_drag_ML_calc( &
        session, input_tensors, output_tensors &
    )

        type(TF_Session) :: session
        type(TF_Tensor), dimension(:) :: input_tensors, output_tensors

        type(TF_Status) :: stat
        character(100) :: message
        type(TF_Operation), dimension(1) :: target_opers

        stat = TF_NewStatus()

        call TF_SessionRun( &
            session, &
            inputs_1, input_tensors, &
            size(input_tensors), &
            outputs_1, output_tensors, &
            size(output_tensors), &
            target_opers, 0, stat &
        )
        if (TF_GetCode(stat) .ne. TF_OK) then
            call TF_Message(stat, message)
            write(*,*) TF_GetCode(stat), message
            stop
        endif
        call TF_DeleteStatus(stat)

    end subroutine cg_drag_ML_calc

subroutine cg_drag_ML(uuu, vvv, psfc, lat, gwfcng_x, gwfcng_y)

  !-----------------------------------------------------------------
  !    cg_drag_ML returns the x and y gravity wave drag forcing
  !    terms following calculation using an external neural net.
  !
  !-----------------------------------------------------------------
  
  !-----------------------------------------------------------------
  !    intent(in) variables:
  !
  !       is,js    starting subdomain i,j indices of data in 
  !                the physics_window being integrated
  !       uuu,vvv  arrays of model u and v wind
  !       psfc     array of model surface pressure
  !       lat      array of model latitudes at cell boundaries [radians]
  !
  !    intent(out) variables:
  !
  !       gwfcng_x time tendency for u eqn due to gravity-wave forcing
  !                [ m/s^2 ]
  !       gwfcng_y time tendency for v eqn due to gravity-wave forcing
  !                [ m/s^2 ]
  !
  !-----------------------------------------------------------------
  
  real, dimension(:,:,:), intent(in)    :: uuu, vvv
  real, dimension(:,:),   intent(in)    :: lat, psfc
  
  real, dimension(:,:,:), intent(out), target   :: gwfcng_x, gwfcng_y
  
  !-----------------------------------------------------------------

  !-------------------------------------------------------------------
  !    local variables:
  !
  !       dtdz          temperature lapse rate [ deg K/m ]
  !
  !---------------------------------------------------------------------

  real, dimension(:,:), allocatable, target  :: uuu_reshaped, vvv_reshaped
  real, dimension(:,:), allocatable, target    :: lat_reshaped, psfc_reshaped

  integer :: imax, jmax, kmax, j, k

  integer(c_int), parameter :: dims_out = 2
  integer(c_int64_t) :: shape_out(dims_out)

  ! Set up types of input and output data and the interface with C
  type(TF_Tensor), dimension(1) :: gwfcng_x_tensors, gwfcng_y_tensors
  integer(c_int), parameter :: n_inputs = 3
  type(TF_Tensor), dimension(n_inputs) :: model_input_arr
  real, dimension(:,:), pointer :: output_x_data_ptr, output_y_data_ptr
  
  !----------------------------------------------------------------

  ! reshape tensors as required
  imax = size(uuu, 1)
  jmax = size(uuu, 2)
  kmax = size(uuu, 3)

  ! Note that the '1D' tensor has 2 dimensions, one of which is size 1
  shape_out = (/ kmax, imax*jmax /)

  ! flatten data (nlat, nlon, n) --> (nlat*nlon, n)
  allocate( uuu_reshaped(kmax, imax*jmax) )
  allocate( vvv_reshaped(kmax, imax*jmax) )
  allocate( lat_reshaped(1, imax*jmax) )
  allocate( psfc_reshaped(1, imax*jmax) )

  do j=1,jmax
      do k=1, kmax
          uuu_reshaped(k, (j-1)*imax+1:j*imax) = uuu(:,j,k)
          vvv_reshaped(k, (j-1)*imax+1:j*imax) = vvv(:,j,k)
      end do
      lat_reshaped(1, (j-1)*imax+1:j*imax) = lat(:,j)*RADIAN
      psfc_reshaped(1, (j-1)*imax+1:j*imax) = psfc(:,j)
  end do

  ! Create input/output tensors from the above arrays
  model_input_arr(2) = r64_2_associate_tensor(lat_reshaped)
  model_input_arr(1) = r64_2_associate_tensor(psfc_reshaped)

  ! Zonal
  model_input_arr(3) = r64_2_associate_tensor(uuu_reshaped)

  ! Run model and Infer
  call cg_drag_ML_calc(model_session_1, model_input_arr, gwfcng_x_tensors)
  
  ! Meridional
  call TF_DeleteTensor(model_input_arr(3))
  model_input_arr(3) = r64_2_associate_tensor(vvv_reshaped)
  ! Run model and Infer
  call cg_drag_ML_calc(model_session_1, model_input_arr, gwfcng_y_tensors)


  ! Convert back into fortran types, reshape, and assign to gwfcng
  call c_f_pointer(TF_TensorData(gwfcng_x_tensors(1)), output_x_data_ptr, shape_out)
  call c_f_pointer(TF_TensorData(gwfcng_y_tensors(1)), output_y_data_ptr, shape_out)
  
  do j=1,jmax
      do k=1, kmax
          gwfcng_x(:,j,k) = output_x_data_ptr(k, (j-1)*imax+1:j*imax)
          gwfcng_y(:,j,k) = output_y_data_ptr(k, (j-1)*imax+1:j*imax)
      end do
  end do

  ! Cleanup
  call TF_DeleteTensor(model_input_arr(1))
  call TF_DeleteTensor(model_input_arr(2))
  call TF_DeleteTensor(model_input_arr(3))
  call TF_DeleteTensor(gwfcng_x_tensors(1))
  call TF_DeleteTensor(gwfcng_y_tensors(1))
  deallocate( uuu_reshaped )
  deallocate( vvv_reshaped )
  deallocate( lat_reshaped )
  deallocate( psfc_reshaped )


end subroutine cg_drag_ML
    subroutine cg_drag_ML_end()

        type(TF_Status) :: stat
        character(100) :: message

        stat = TF_NewStatus()
        ! Delete the model variables.
        ! Model: saved_model/
        call TF_DeleteGraph(model_graph_1)
        call TF_DeleteSession(model_session_1, &
            stat)
        if (TF_GetCode(stat) .ne. TF_OK) then
            call TF_Message(stat, message)
            write(*,*) TF_GetCode(stat), message
            ! we don't stop here so all resources can try to delete
        endif
        call TF_DeleteStatus(stat)

    end subroutine cg_drag_ML_end

    function r64_2_associate_tensor(input_array, input_shape, input_size)
        type(TF_Tensor) :: r64_2_associate_tensor
        real, dimension(:, :), target :: input_array
        integer(kind=c_int64_t), dimension(2), optional :: input_shape
        integer(kind=c_size_t), optional :: input_size

        integer(kind=c_int64_t), dimension(2) :: input_shape_act
        integer(kind=c_int64_t) :: swap
        integer :: i, sz_inp_act
        integer(kind=c_size_t) :: input_size_act

        if (.not.present(input_shape)) then
            input_shape_act = shape(input_array)
        else
            input_shape_act = input_shape
        end if

        ! Reverse the index order of the shape.
        sz_inp_act = size(input_shape_act) + 1 ! 1-indexed arrays
        do i = 1, sz_inp_act / 2
            swap = input_shape_act(i)
            input_shape_act(i) = input_shape_act(sz_inp_act - i)
            input_shape_act(sz_inp_act - i) = swap
        enddo

        if (.not.present(input_size)) then
            ! sizeof is non-standard but seems to be widely supported.
            input_size_act = int(sizeof(input_array), kind=c_size_t)
        else
            input_size_act = input_size
        end if

        r64_2_associate_tensor = TF_NewTensor(TF_DOUBLE, input_shape_act, 2, &
            c_loc(input_array), input_size_act)

    end function r64_2_associate_tensor

end module cg_drag_ML_mod
